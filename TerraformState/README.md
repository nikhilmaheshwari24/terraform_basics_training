# Terraform State

## Introduction to Terraform State

We now have a pretty good idea about how to get started with Terraform. We have learned how to write simple configuration files using HCL, declare and use variables, use reference expressions, and link resources together. Now let's get introduced to Terraform State and see what really happens under the hood when we run Terraform commands to provision infrastructure. 

Before we understand Terraform state, let us see the Terraform workflow once again. We have a configuration files in a directory called terraform-local-file. The main Terraform configuration with the resource blocks is defined in the file called main.tf. The variables used are defined inside the file called variables.tf. At this point, we do not have the local file resource created. 

```bash

```

First, we'll run the terraform init command to download the necessary plugins. Next, we can generate the execution plan by running the terraform plan command. The very first line that is printed when we run this command shows that Terraform tries to refresh the state in-memory prior to the plan. Since it's the first time we are running the terraform plan command, there will be no details related to a state printed, therefore implying that there is no state recorded at this moment in time. From this, Terraform also understands that currently there are no resources provisioned based on the configuration files, and then creates an execution plan of create. 

Moving on, let us now run terraform apply. This command also tries to refresh the in-memory state, finds that there is no state recorded at the moment, and then proceeds to create an execution plan. Once confirmed, Terraform creates the local file resource as expected. Terraform creates a unique ID for the resource as seen in the command output. As expected, we can see that the file has been created with the content that we provided. 

### Now, what will happen if you run the terraform apply command again? 

Terraform knows that a local file resource by the name of pet and the same ID that we just saw already exists and it takes no further action. 

### So How does Terraform know that? How does it know that the local file resource already exists? 

To understand that, let us check the contents of the configuration directory again. We can now see that there is an additional file called **`terraform.tfstate`** created in this directory. This file is called the terraform state file, which was created as a consequence of the terraform apply command that created the resource in the first place. 

**`This file is not created until the terraform apply command is run at least once. 
`**

The state file is a **`JSON`** data structure that maps the real-world infrastructure resources to the resource definition in the configuration files. If we inspect the contents of this state file, we can see that it has the complete record of the infrastructure created by Terraform. In this case, we have a single resource of type local file and a logical name called pet. The details such as the resource ID, provider information, and all the resource attributes are stored within this file. It contains every little detail pertaining to the infrastructure that was created by Terraform, and it uses it as a single source of truth when using commands such as terraform plan and apply. 

If we make a change to the configuration file now, and rerun the terraform plan or apply command, Terraform by default refreshes the state again and compares it against the configuration file. It now knows that the resource argument called content has a different value in the configuration file as compared to the terraform state and the real world. The configuration value uses the string "We love pets!" for the content argument, but the state file record shows that the actual content in this file is "I love pets!" As a result, Terraform knows that the resource must be recreated and when we run terraform apply, it updates the state file as well. 

From the output of the apply command, we can see that the older local_file resource with the older ID is deleted and replaced with a new resource with a completely different ID with the updated content. The same can be seen in the terraform state file as well. It no longer has a reference for the older resource ID and now has the details recorded for the replaced file resource. At this point in time, the configuration file and the state file are in sync, and since they do not have any differences, there will be no changes to apply subsequently. The example we have used here contains only a single resource and the same is reflected in the terraform state file. In a real-world scenario, a terraform configuration may contain numerous resources belonging to several different providers. Irrespective of the size of the infrastructure, Terraform will always create a state file and use it to store information about the state of the infrastructure in the real world. It is non-optional.

## Purpose of State

In this lecture, we will see the purpose of using State in Terraform. We already saw how Terraform uses state file to map the resource configuration to the real world infrastructure. This mapping allows Terraform to create execution plans, when a drift is identified between the resource configuration files and the state. Hence, a state file can be considered to be a blueprint of all the resources that are for managers out there in the real world. When Terraform creates a resource, it records its identity in the state. Be it the local file resource that creates a file in the machine, a logical resource such as the random pet, which just throws out the random pet name or resources in the cloud, each resource created and managed by Terraform would have a unique ID which is used to identify the resources in the real world. Besides the mapping between resources and the configuration and the real world, the state file also tracks metadata details such as resource dependencies. 

Earlier, we learn that Terraform supports two types of dependencies, the implicit and the explicit. If we inspect the example configuration file, we can see that we have three resources to provision here. The local file resource called pet depends on the random pet resource. This is evident from the content argument in the local file resource block that uses a reference to the random pet resource. The local file resource called cat is unrelated to the other and hence it can be created in parallel with the random pet resource. 

```bash

```

When we apply this configuration, the random pet resource called my-pet and the local file called cat can be created first at the same time, but the local file resource called pet can only be created after the random pet resource is created. We can see that the local file with the name cat and the random pet resource with the name my-pet are the first resources to be created. Once that is done, only then is the local file resource called pet created. Until now, we do not rely on state for the provisioning, but what if we decide to delete the random pet resource and the dependent local file from the configuration. 

Let us now look at what happens when we remove resources from the file. For example, we remove the local file and the random pet resource from the file. If we were to apply the configuration now, Terraform knows that it has to delete these resources. However, in which order does it delete it? Should it delete the random pet resource first or the local file? The information about the resource dependency is no longer available in the configuration file, as we have removed those lines from it. This is where Terraform relies on the state and the fact that it tracks metadata. Within the state file, we can clearly see that the local file resource called pet has a dependency on the random pet resource. Since these two resources have now been removed from the configuration, Terraform now knows that it should delete the local file first followed by the random resource. 

One other benefit of using state is performance. When dealing with a handful number of resources, it may be feasible for Terraform to reconcile state with the real world infrastructure after every single Terraform command such as plan or apply. In the real world, Terraform would manage hundreds and thousands of such resources. When these resources are distributed to multiple providers and especially those that are on the cloud, it is not feasible for Terraform to reconcile state for every Terraform operation. This is because it would take several seconds to several minutes, in some cases, for Terraform to fetch details about every single resource from all the providers, which are configured. For larger infrastructures, this may prove to be too slow. In such cases, the Terraform state can be used as the record of truth without having to reconcile, this would improve the performance significantly. Terraform stores a cache of attribute values for all resources in the state. We can specifically make Terraform to refer to the state file alone while running commands and bypass having to refresh state every time. To do this, we can make use of the **`-refresh=false`** flag with all the Terraform commands that make use of state. When we run the plan with this flag, you can see that Terraform does not refresh state. Instead, it relies on the cache attributes and in this example, the content which has changed in the configuration file, and as a result, the execution plan plots a resource replacement. 

The final benefit of state that we are going to look at is collaboration when working as a team. As we have seen in the previous lectures, the Terraform state file is stored in the same configuration directory in a file called terraform.tfstate. In a normal scenario, this means that the state file resides in the folder or a directory in the end user's laptop. This is all right when starting off with Terraform, learning and implementing small projects individually. However, this is far from ideal when working as a team. Every user in the team should always have the latest state data before running Terraform and make sure that nobody else runs Terraform at the same time. Failure to do so can result in unpredictable errors as a consequence. In such a scenario, it is highly recommended to save the Terraform state file in a remote data store rather than to rely on a local copy. This allows the state to be shared between all members of the team securely. Examples of remote state stores are AmazonWebService's S3 Service, HasiCorp's Consul and Terraform cloud. 