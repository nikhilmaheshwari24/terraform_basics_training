# Terraform Taint

In this lecture, we will take a look at the Terraform taint and untaint command. There would be cases when a resource creation fails when we run Terraform apply. Let's take the same example as before where we use a local provisioner to store the public IP address of the EC2 instance in a file. However, when we try to apply the changes, the resource creation failed because the part specified in the command of the local exit provisioner is invalid. When this happens and a resource creation fails for any reason, Terraform marks the resource as tainted. This can be seen when we run the Terraform plan command again. The resource called web server is tainted, and as a result, Terraform will attempt to recreate it during the subsequent apply. In this example, the step that failed was the command executed by the local exit provisioner. The EC2 instance itself was successfully provisioned. In spite of this, Terraform will attempt to recreate the entire resource because it was marked tainted. Now there would be cases when we want to force a particular resource to be recreated. For example, consider a case where manual changes were made to an AWS instance which is managed by Terraform, such as changing the version of nginx running on it by manual methods. To reword this, we can either destroy the resource using the command Terraform destroy, and then run apply again, or the better way would be to taint the resource using the Terraform taint command like this. When we run Terraform plan next, we will see that the resource is set to be recreated. To undo a taint that was applied for a specific resource, use the Terraform untaint command like this. This resource will not be recreated now during a subsequent Terraform apply.

# Debugging

In this lecture, we will learn how to enable and use debugging in Terraform. When things go wrong in Terraform, the obvious place to look for the cause is in the logs. Although Terraform apply often provides a good indication of what may have caused an error during the provisioning, there may be cases where we need to look a little bit deeper. To do this we can make use of environment variable called tf_log and set it to one of the log level values. Terraform offers file log levels, info, warning, error, debug and trace, with trace being the most verbose logging level of them all. When we run Terraform commands after setting the environment variable, we should see a lot of additional logs based on the level that has been set. For example, a simple Terraform plan with logging set to trace would display hundreds and thousands of lines, including those that are run internally by the Terraform plugin in use. These logs are particularly useful when things are not working as expected within Terraform internally. In such cases, the logs generated can also be used to file a bug report with Terraform. To store the logs persistently in a file, use the environment variable called tf_log_part and point it to a file like this. This will ensure that all the logs that are generated are recorded in that file. To disable logging completely, unset the environment variables like this. That's it for this lecture. Let's head over to the hands-on lab and practice working with Terraform taint and debugging.

# Terraform Import

In this lecture, we will learn how to input existing infrastructure into the Terraform configuration using Terraform input command. So far in this course, we have created and managed resources using Terraform. Ideally, we would want the provisioning, updating and deletions of all infrastructure resources to be managed by Terraform. in real world projects, there's a big chance that this is not always the case. For example, there may be AWS resources that are created using the management console or other resources that are provision using another IAC tool such as Ansible. What if you want to bring resources created by other methods into the control of Terraform? How do we do that? Earlier, we saw how to read data from other resources that are not managed by the current Terraform configuration by making use of data sources. While this helps us to make use of the attributes of the data source, the resource itself is not managed by Terraform at this stage. For example, here we have a data source block which will read the attributes of an existing AWS instance with the matching instance ID. The data source is called "newserver," and we are making use of an output variable to print the value of the public IP of this EC2 instance. In spite of this, the actual EC2 instance with this specific instance ID is not managed by Terraform. We cannot update or delete this resource using Terraform commands. To bring a resource completely in the management and control of Terraform, we have to import it. For that, we can make use of the Terraform import command. The syntax to use this command is as follows. The command to be used as Terraform import. This is followed by the resource address, which is the resource type and the resource name separated by a dot. Following this is the resource attribute that can uniquely identify the resource such as the ID. Using the same example that we use for the data source, the import command would translate to this. It feed on this command now. Don't expect our main.tf or any other configuration files within the directory to be updated with the resource block, put in into this AWS instance. Instead, the first time we run this command, we should see an error like this. This is because Terraform import does not update the configuration files at all. It only updates the state file with the details of the infrastructure being imported. As of this recording and as of Terraform version 0.13, we have to manually write the configuration for the resource being important. In order to fix this error and continue with the iimport, we can write an empty resource block like this. You will notice that the blog does not contain any arguments at this moment, required or optional, but that's okay for now. Once that resource block is defined, we can rerun the iimport command, and this time it should go through without any errors. The resource is now imported into the Terraform state file. Next, we can complete the resource block for the webserver 2 by defining all the resource arguments and their values. To get the values for the arguments for this EC2 instance, we can inspect the instance from the management console. Alternatively, since it's already been imported, we can also inspect the state file instead and look for the attributes. Once we have all the details, fill in the arguments in the resource block for the webserver 2. Here, we have added the values for AMI instance type, the key name and the security group ID used by this instance. Once all the arguments and the correct values have been provided, the Terraform plan will refresh the state and understand that the EC2 instance already exists and will carry out no action. The resource is now under the control of Terraform. Going forward, any changes to this resource can we carry it out by updating the configuration file, add following the Terraform workflow off in it, plan and apply. Now let's head over to the hands-on labs and practice working with the Terraform import command.